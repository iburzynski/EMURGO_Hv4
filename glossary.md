## A

* **Accumulator:** a parameter to a recursive function, which is given a new value with each recursive call.

* **Algebraic Data Type:**

* **Applicative (Functor):**

* **Argument:** a value to which a function is applied, which binds to a corresponding parameter in the function definition.

* **Arity:** the number of parameters defined for a function

## B

* **Base:** term used for the Haskell standard library.

* **Base Case:** a function

## C

* **Camel Case:**

* **Case Expression:**

* **Closure:**

* **Composition:**

* **Conditional Expression:** an expression that applies one or more *predicate* functions and

* **Context:** see *parameterized type*.

* **Currying:** the process of transforming a function with multiple parameters into a function with a single parameter, which returns another function which has a single parameter, etc., until every parameter is exhausted. All Haskell functions are considered curried. Curried functions allow *partial application*.

## D

* **Declarative Style:**

* **Destructuring:** See *pattern matching*.

## E

* **Equational Reasoning:**

* **Expression:** a unit of code that evaluates to a value. Contrast with *statement*. Everything is an expression in Haskell.

## F

* **First-Class Functions:** a language feature in which functions are treated the same as any other value. They can be:
  * used as arguments to other functions
  * returned as values from other functions
  * contained within data structures (lists, tuples, etc.)

* **Fold:**

* **Functor:**

## G

* **Getter:** a function which, when applied to a value of a *record type*, returns the data associated with a particular field.

* **GHC:** Glasgow Haskell Compiler, the compiler that produces native executable code from Haskell code.

* **GHCi:**

* **Guard:**

## H

* **Higher-Order Function:**

## I

* **Immutability:**

* **Instance:**

* **IO:**

* **Imperative Style:**

* **Infix Notation:**

## L

* **Lambda Calculus:**

* **Lambda Expression:** an anonymous function

* **Lazy Evaluation:**

* **Lexical Scope:**

* **Linked List:**

* **List Comprehension:**

## M

* **Method:**

* **Monad:**

* **Monad Transformer:**

* **Monoid:**

## O

* **Operator:**

* **Operator Section:**

## P

* **Parameter:**

* **Partial Application:**

* **Partial Function:**

* **Pattern Matching:**

* **Pointfree Style:** a style of writing functions as a composition of other functions, without mentioning their parameters
https://wiki.haskell.org/Pointfree

* **Polymorphism:**
  * **Ad Hoc:**
  * **Parametric:**

* **Predicate:** a function returning a boolean value (True or False)

* **Prefix Notation:**

* **Prelude:** a *module* containing a small set of standard definitions from *Base*, which is included automatically into all Haskell modules.

* **Primitive Recursion:**

* **Product Type:**

* **Pure Function:**

## R

* **Record Type:**

* **Recursive Function:**

* **Recursive Type:**

* **Refactoring:** the process of incrementally improving code

* **Referential Transparency:**
Evaluation of the expression simply changes the form of the expression but never its value. All references to the value are therefore equivalent to the value itself and the fact that the expression may be referred to from other parts of the program is of no concern.
equal subexpressions can be interchanged in the context of a larger expression to give equal results
An essential advantage of referential transparency is that it allows for *equational reasoning* about programs.
https://www.cas.mcmaster.ca/~kahl/reftrans.html


## S

* **Semigroup:**

* **Statement:**

* **Strict Evaluation:**

* **Sum Type:**

* **Syntactic Sugar:**

## T

* **Thunk:** a value that remains to be evaluated. See *lazy evaluation*.

* **Total Function:**

* **Tuple:**

* **Type:**

* **Typeclass:**

* **Type Constructor:**

* **Type Variable:**

## V

* **Value:**

* **Value Constructor:**

* **Variable:**